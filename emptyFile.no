// So, this is what I have now, and it works just the way I want it to, except for the inclusion of working abort signal listening code in all the long-running loops in xRootOfy and 
// the functions that are called by it. When you kick back sections of code which include fixes and or updates please be sure to retain all of my comments etc. in your sections of code. 

package main

import (
	"fmt"
	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/app"
	"fyne.io/fyne/v2/canvas"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/theme"
	"fyne.io/fyne/v2/widget"
	"image/color"
	"strconv"
)

// @formatter:off

var (
			bgsc = canvas.NewRectangle(color.NRGBA{R: 150, G: 180, B: 160, A: 240}) // Light green
			bgwc = canvas.NewRectangle(color.NRGBA{R: 110, G: 160, B: 255, A: 150}) // Light blue, lower number for A: means less opaque, or more transparent
		
			outputLabel1 = widget.NewLabel("\nSelect one of the brightly-colored panels to estimate π via featured method...\n\n")
			scrollContainer1 = container.NewVScroll(outputLabel1)
		
			myApp = app.New()
			window1 = myApp.NewWindow("Rick's Pi calculation Demo, set #1")
			// currentDone    chan bool // how things were prior to this latest project of bringing 
)
var tm = NewTrafficManager(outputLabel2)
var currentDone = tm.stop

func main() {
	countAndLogSLOC() 
	calculating = false
	myApp.Settings().SetTheme(theme.LightTheme()) 
	window1.Resize(fyne.NewSize(1900, 1600))

	scrollContainer1 = container.NewVScroll(outputLabel1)
	
	scrollContainer1.SetMinSize(fyne.NewSize(1900, 930)) // was 1900, 1050 before adding the scoreBoard, which required this adjustment 
	
	outputLabel1.Wrapping = fyne.TextWrapWord 

		coloredScroll := container.NewMax(bgsc, scrollContainer1) 
	
		windowContent := container.NewMax(bgwc, coloredScroll) 

/*
.
.
 */
	terminalDisplay := widget.NewTextGrid()
	terminalDisplay.SetText("Terminal Output:\n\nWaiting for calculation...")

	// Button only being used as a title-label for nifty_scoreBoard
	calcButton := widget.NewButton("Calculate Pi on a ScoreBoard", func() {
		updateOutput1("\n- * - * - that button does nothing - * - * -\n\n")
	})

	contentForScoreBoard := container.NewVBox(
		calcButton,
		terminalDisplay,
	)
/*
.
.
 */
	// Custom colored ::: Buttons1 - - - - - - - - - follow - - - - - - - - - - - v v v v v v v v v - - - - - - 
	/*
	.
	.
	 */
	archimedesBtn1 := NewColoredButton(
	"Archimedes method for finding π, modified by Richard Woolley\n" +
		"easy to understand geometric method using big.Float variables\n" +
		"produces 3,012 digits of delicious Pi in under a minute, 230BCE\n" +
		"             -*-*-*- Rick's personal favorite -*-*-*-          ",
		color.RGBA{255, 110, 110, 215},
		
		func() {
			if calculating {
				return
			}
			calculating = true
			for _, btn := range buttons1 {
				btn.Disable()
			}
			// We want to cause the button that corresponds to the currently executing method to remain bright, while the other buttons remain dimmed during calculating ...
			for _, btn := range archiBut { 
				calculating = true 
				btn.Enable() 
			} //  ... we do it like this ^ ^ ^ because, we are inside the creation of archimedesBtn1 [ it was the simplest way to deal with a timing and scoping issue ]
			currentDone = make(chan bool) 
			updateOutput1("\nRunning ArchimedesBig...\n\n")
			go func(done chan bool) {
					defer func() { 
						calculating = false
						updateOutput1("Calculation definitely finished; possibly aborted\n")
					}()
				ArchimedesBig(updateOutput1, done) // ::: func < - - - - - - - - - - - - - < -
					calculating = false
					for _, btn := range buttons1 {
						btn.Enable()
					}
			}(currentDone)
		},
	)
	/*
	.
	.
	 */
	
	JohnWallisBtn1 := NewColoredButton(
	"John Wallis infinite series -- 40 billion iterations -- runs 5m30s\n" +
		"π = 2 * ((2/1)*(2/3)) * ((4/3)*(4/5)) * ((6/5)*(6/7)) ...\n" +
		"only manages to do 10 digits of Pi in well-over five minutes\n" +
		"an infinite series circa 1655    --- served here by Rick Woolley ---",
		color.RGBA{110, 110, 255, 185}, 
		
		func() {
			if calculating {
				return
			}
			calculating = true
			for _, btn := range buttons1 {
				btn.Disable()
			}
			for _, btn := range walisBut {
				btn.Enable()
			}
			currentDone = make(chan bool) 
			updateOutput1("\nRunning John Wallis...\n\n")
			go func(done chan bool) { 
					defer func() { 
						calculating = false 
						updateOutput1("Calculation definitely finished; possibly aborted\n")
					}()
				JohnWallis(updateOutput1, done) 
					calculating = false
					for _, btn := range buttons1 {
						btn.Enable()
					}
			}(currentDone)
			fmt.Printf("here at the end of JohnWallisBtn1 calculating is %t\n", calculating)
		},
	)
/*
.
.
 */

	SpigotBtn1 := NewColoredButton(
	"The Spigot Algorithm, a Leibniz series. Served hot, bite by byte\n" +
		"spits out a nearly-unlimited, continuous stream of Pi goodness\n" +
		"This trick made possible by a bit of code mooched off of GitHub\n" +
		"bakes π without using any floating-point arithmetic",
		color.RGBA{255, 255, 100, 235},
		
		func() {
			var spigotDigits int = 1460 // to resolve a scoping issue 
			if calculating {
				return
			}
			calculating = true
			for _, btn := range buttons1 {
				btn.Disable()
			}
			for _, btn := range spigotBut {
				calculating = true
				btn.Enable()
			}
			currentDone = make(chan bool)
			updateOutput1("\nRunning The Spigot...\n\n")
			
			// In the case of the spigot, retain this dialog please. 
			showCustomEntryDialog(
				"Input Desired number of digits",
				"Any number less than 1461",
				func(input string) {
					if input != "" { // This if-else is part of the magic that allows us to dismiss a dialog and allow others to run after the dialog is canceled/dismissed.
						input = removeCommasAndPeriods(input) 
						val, err := strconv.Atoi(input)
						if err != nil { // we may force val to become 460, or leave it alone ...
							fmt.Println("Error converting input:", err)
							updateOutput1("\nInvalid input, using default 1460 digits\n")
							val = 1460
						} else if val <= 0 {
							updateOutput1("\nInput must be positive, using default 1460 digits\n")
							val = 1460
						} else if val > 1460 {
							updateOutput1("\nInput must be less than 1461 -- using default of 1460 digits\n")
							val = 1460 
						} else {
							spigotDigits = val 
						}
						
						go func(done chan bool) { 
								defer func() { 
									calculating = false 
									updateOutput1("\nCalculation definitely finished; possibly aborted\n")
								}()
							TheSpigot(updateOutput1, spigotDigits, done) 
								calculating = false
								for _, btn := range buttons1 {
									btn.Enable()
								}
						}(currentDone)
					} else {
						// dialog canceled 
						updateOutput1("\nspigot calculation canceled, make another selection\n")
						for _, btn := range buttons1 {
							btn.Enable()
						}
						calculating = false // ::: this is the trick to allow others to run after the dialog is canceled/dismissed.
					}
				},
			)
		}, 
	)
	/*
	.
	.
	 */ 
	
	ChudnovskyBtn1 := NewColoredButton(
	"Chudnovsky -- by David & Gregory Chudnovsky -- late 1980s\n" +
		"extremely efficient, quickly bakes world-record quantities of Pi\n" +
		"this algorithm is a rapidly converging infinite series which\n" +
		"leverages properties of j-invariant from elliptic function theory",
		color.RGBA{100, 255, 100, 215}, 
		
		func() {
			// 
			var chudDigits int
				if calculating {
					return
				}
				calculating = true
				for _, btn := range buttons1 {
					btn.Disable()
				}
				for _, btn := range chudBut { 
					calculating = true 
					btn.Enable() 
				}
			currentDone = make(chan bool) // ::: New channel per run
			updateOutput1("\nRunning Chudnovsky...\n\n")
	
			// unsure about retaining dialog for chud
			showCustomEntryDialog(
				"Input Desired number of digits",
				"Any number less than 49,999",
				func(input string) {
					if input != "" { // This if-else is part of the magic that allows us to dismiss a dialog and allow others to run after the dialog is canceled/dismissed.
						input = removeCommasAndPeriods(input)
						val, err := strconv.Atoi(input)
						if err != nil {
							fmt.Println("Error converting input:", err)
							updateOutput1("Invalid input, using default 49,000 digits")
						} else if val <= 0 {
							updateOutput1("Input must be positive, using default 49000 digits")
						} else if val > 50000 {
							updateOutput1("Input must be less than 50,000 -- using default of 49,000 digits")
						} else {
							chudDigits = val
						}
						go func(done chan bool) { 
								defer func() { 
									calculating = false
									updateOutput1("Calculation definitely finished; possibly aborted\n")
								}()
							chudnovskyBig(updateOutput1, chudDigits, done) 
								calculating = false
								for _, btn := range buttons1 {
									btn.Enable()
								}
						}(currentDone)
					} else {
						// dialog canceled 
							updateOutput1("chudnovsky calculation canceled, make another selection")
							for _, btn := range buttons1 {
								btn.Enable()
							}
							calculating = false // ::: this is the trick to allow others to run after the dialog is canceled/dismissed.
					}
				},
			)
		},
	)
	/*
	.
	.
	 */

	MontyBtn1 := NewColoredButton(
		"Monte Carlo method for converging on π  --  big floats, & float64\n" +
			"Flavor: no fancy equations are used, only Go's pure randomness\n" +
			"4 digits of pi in 21s; 7 digits possible in 1h30m with a 119k grid\n" +
			"                   -*-*- Rick's second-favorite method -*-*-     ",
		color.RGBA{255, 255, 100, 235},

		func() {
			var MontDigits string
			if calculating {
				return
			}
			calculating = true
			for _, btn := range buttons1 {
				btn.Disable()
			}
			for _, btn := range montBut {
				calculating = true
				btn.Enable()
			}
			currentDone = make(chan bool) 
			updateOutput1("\nRunning Monte Carlo ...\n\n")

			showCustomEntryDialog(
				"Input Desired number of grid elements",
				"max 120,000; 10,000 will produce 4 pi digits, 110,00 may get you 5 digits",
				func(input string) {
					if input != "" { // This if-else is part of the magic that allows us to dismiss a dialog and allow others to run after the dialog is canceled/dismissed.
						input = removeCommasAndPeriods(input)
						val, err := strconv.Atoi(input) 
						if err != nil {
							fmt.Println("Error converting input:", err)
							updateOutput1("Invalid input, using default 10,000 digits")
						} else if val <= 1 {
							updateOutput1("Input must be greater than 1, using default 10,000 digits")
						} else if val > 120000 {
							updateOutput1("Input must be less than 120,001 -- using default of 10,000 digits")
						} else {
							MontDigits = strconv.Itoa(val) 
						}
						go func(done chan bool) { 
								defer func() { 
									calculating = false 
									updateOutput1("Calculation definitely finished; possibly aborted\n")
								}()
							Monty(updateOutput1, MontDigits, done)
								calculating = false
								for _, btn := range buttons1 {
									btn.Enable()
								}
						}(currentDone)
					} else {
						// dialog canceled 
						updateOutput1("Monte Carlo calculation canceled, make another selection")
						for _, btn := range buttons1 {
							btn.Enable()
						}
						calculating = false // ::: this is the trick to allow others to run after the dialog is canceled/dismissed.
					}
				},
			)
		},
	)
	/*
		.
		.
	*/
	
	GaussBtn1 := NewColoredButton(
	"Gauss-Legendre -- C F Gauss, refined by Adrien-Marie Legendre\n" +
		"π ≈ (aₙ + bₙ)² / (4 tₙ)\n" +
		"only manages to do 10 digits of Pi in well-over five minutes\n" +
		"an infinite series circa 1655    --- served here by Rick Woolley ---",
		color.RGBA{100, 255, 100, 215},
		
		func() {
			if calculating {
				return
			}
			calculating = true
			for _, btn := range buttons1 {
				btn.Disable()
			}
			for _, btn := range gaussBut {
				calculating = true
				btn.Enable()
			}
			currentDone = make(chan bool)
			updateOutput1("\nRunning Gauss...\n\n")
			go func(done chan bool) { 
					defer func() {  
						calculating = false 
						updateOutput1("Calculation definitely finished; possibly aborted\n")
					}()
				Gauss_Legendre(updateOutput1, done) // ::: func < - - - - - - - - - - - - - < -
					calculating = false
					for _, btn := range buttons1 {
						btn.Enable()
					}
			}(currentDone)
		},
	)
	/*
	.
	.
	 */
	
	CustomSeriesBtn1 := NewColoredButton(
	"Custom series -- I don't remember where it's from ... \n" +
		"but it is very quick -- 4s gets us 9 digits of Pi\n" +
		"π = (4/1) - (4/3) + (4/5) - (4/7) + (4/9) - (4/11) + (4/13) - (4/15) ...",
		color.RGBA{255, 120, 120, 215}, // Greenish for variety
		
		func() {
			if calculating {
				return
			}
			calculating = true
			for _, btn := range buttons1 {
				btn.Disable()
			}
			for _, btn := range customBut {
				calculating = true
				btn.Enable()
			}
			currentDone = make(chan bool) 
			updateOutput1("\nRunning Custom Series ...\n\n")
			go func(done chan bool) { 
					defer func() { 
						calculating = false
						updateOutput1("Calculation definitely finished; possibly aborted\n")
					}()
				CustomSeries(updateOutput1, done)
					calculating = false
					for _, btn := range buttons1 {
						btn.Enable()
					}
			}(currentDone)
		},
	)
	/*
	.
	.
	 */
	
	GregoryLeibnizBtn1 := NewColoredButton(
	"Gregory-Leibniz -- runs 20sec -- gives 10 digits of Pi\n" +
		"James Gregory 1638–1675  Gottfried Wilhelm Leibniz 1646-1716\n" +
		"π = 4 * ( 1 - 1/3 + 1/5 - 1/7 + 1/9 ...) ",
		color.RGBA{110, 110, 255, 185},
		
		func() {
			if calculating {
				return
			}
			calculating = true
			for _, btn := range buttons1 {
				btn.Disable()
			}
			for _, btn := range gottfieBut { 
				calculating = true
				btn.Enable()
			}
			currentDone = make(chan bool)
			updateOutput1("\nRunning Gregory-Leibniz...\n\n")
			go func(done chan bool) { 
				defer func() { 
					calculating = false
					updateOutput1("Calculation definitely finished; possibly aborted\n")
				}()
				GregoryLeibniz(updateOutput1, done) 
				calculating = false
				for _, btn := range buttons1 {
					btn.Enable()
				}
			}(currentDone)
		},
	)
	/*
	.
	.
	 */
	
	archiBut = []*ColoredButton{archimedesBtn1} // All of these 8 *But items are a trick/kluge used as bug preventions -- to keep methods from being started or restarted in parallel (over-lapping) 
	walisBut = []*ColoredButton{JohnWallisBtn1} 
	spigotBut = []*ColoredButton{SpigotBtn1} 
	chudBut = []*ColoredButton{ChudnovskyBtn1} 
	montBut = []*ColoredButton{MontyBtn1} 
	gaussBut = []*ColoredButton{GaussBtn1}
	customBut = []*ColoredButton{CustomSeriesBtn1}
	gottfieBut = []*ColoredButton{GregoryLeibnizBtn1}
	
	buttons1 = []*ColoredButton{archimedesBtn1, JohnWallisBtn1, SpigotBtn1, ChudnovskyBtn1, MontyBtn1, GaussBtn1, CustomSeriesBtn1, GregoryLeibnizBtn1,} // used only for range btn.Enable()

		content1 := container.NewVBox(widget.NewLabel("\nSelect a method to estimate π:\n"),
			container.NewGridWithColumns(4, archimedesBtn1, JohnWallisBtn1, SpigotBtn1,
				ChudnovskyBtn1, MontyBtn1, GaussBtn1, CustomSeriesBtn1, GregoryLeibnizBtn1, contentForScoreBoard),
			windowContent,
		)
/*
.
.
 */
	// ::: drop-down menus -- same for all windows  -  -  --  -  -  --  -  -  --  -  -  --  -  -  --  -  -  --  -  -  --  -  -  --  -  -  --  
	logFilesMenu := fyne.NewMenu("Log-Files",
		fyne.NewMenuItem("View Log 1", func() { dialog.ShowInformation("Log Files", "Viewing Log 1", window1) }),
		fyne.NewMenuItem("View Log 2", func() { dialog.ShowInformation("Log Files", "Viewing Log 2", window1) }),
	)
	additionalMethodsMenu := fyne.NewMenu("Other-Methods",
		fyne.NewMenuItem("Home-Page (Pi methods)", func() { window1.Show() }),
		fyne.NewMenuItem("Second-page of Pi methods", func() { createWindow2(myApp).Show() }), 
		fyne.NewMenuItem("Odd Pi calculators", func() { createWindow3(myApp).Show() }),
		fyne.NewMenuItem("Misc Maths", func() { createWindow4(myApp).Show() }), // maybe our roots demo will live here some day
	)
	optionsMenu := fyne.NewMenu("Options",
		fyne.NewMenuItem("Begin the ScoreBoard of Pi", func() {
			
			// dialog.ShowInformation("ScoreBoard", "Use Abort in Menu\nPrior to dismissing with OK", window1)
			if calculating {
				fmt.Println("Calculation already in progress")
				return
			}
			calculating = true
			currentDone = make(chan bool)
			termsCount = 0

			go func(done chan bool) {
				defer func() {
					calculating = false
					terminalDisplay.SetText(fmt.Sprintf("Terminal Output:\n\nCalculation stopped.\nFinal Pi: %.11f\nTerms: %d", <-pichan, termsCount))
				}()

				pie := nifty_scoreBoardG(func(text string) {
					terminalDisplay.SetText(text)
				}, done)

				if pie != 0.0 {
					terminalDisplay.SetText(fmt.Sprintf("Terminal Output:\n\nComputed Value of Pi:\t\t%.11f\n# of Nilakantha Terms:\t\t%d", pie, termsCount))
				}
			}(currentDone)
		}),

		fyne.NewMenuItem("Abort any currently executing method", func() {
			if currentDone == nil {
				updateOutput1("\nNo active calculation to abort, no such currentDone channel exists\n")
				fmt.Println("No active calculation to abort, no such currentDone channel exists")
				return
			}
			select {
			case <-currentDone:
				updateOutput1("\nMenu select determined that currentDone-chan had already been closed; all Goroutines were PREVIOUSLY notified to terminate\n")
				fmt.Println("Menu select determined that currentDone-chan had already been closed; all Goroutines were PREVIOUSLY notified to terminate")
			default:
				tm.Stop()
				// close(currentDone) // ::: not being included in groks latest -- said to swap for tm.stop
				updateOutput1("\nTermination signals were sent to all current processes that may be listening\n")
				fmt.Println("Termination signals were sent to all current processes that may be listening")
			}
		}),
		fyne.NewMenuItem("Show the terminal -- Cmd+Tab to return", func() {
			err := openTerminal()
			if err != nil {
				fmt.Println(err)
				return
			}		}),
	)

	mainMenu := fyne.NewMainMenu(logFilesMenu, additionalMethodsMenu, optionsMenu)
	window1.SetMainMenu(mainMenu)
	
	windowWithBackground := container.NewMax(bgwc, content1)
	
	window1.SetContent(windowWithBackground)
	
	window1.ShowAndRun() 
}
package main

import (
	"fmt"
	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/canvas"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/widget"
	"image/color"
	"strconv"
)

// @formatter:off

var (
	bgsc2 = canvas.NewRectangle(color.NRGBA{R: 130, G: 160, B: 250, A: 140}) // Light blue // was: 130, 160, 250, 160 ::: - -
	bgwc2 = canvas.NewRectangle(color.NRGBA{R: 110, G: 255, B: 160, A: 150}) // Light green ::: - -

	outputLabel2 = widget.NewLabel("Classic Pi calculators, make a selection") // ::: - -
	scrollContainer2 = container.NewScroll(outputLabel2) // ::: - -
	window2 = myApp.NewWindow("Rick's Pi calculation Demo, set #2") // ::: - -

)

// Three Additional Windows: 
// ::: ------------------------------------------------------------------------------------------------------------------------------------------------------------
func createWindow2(myApp fyne.App) fyne.Window {
	window2.Resize(fyne.NewSize(1900, 1600))
	outputLabel2.Wrapping = fyne.TextWrapWord
	scrollContainer2.SetMinSize(fyne.NewSize(1900, 1090))
	coloredScroll2 := container.NewMax(bgsc2, scrollContainer2) // Light blue-ish scroll bg
	
	radicalEntry := widget.NewEntry()
	radicalEntry.SetPlaceHolder("Enter radical index (e.g., 2 or 3)")
	workEntry := widget.NewEntry()
	workEntry.SetPlaceHolder("Enter number to find the root of")

	done := make(chan bool) // local, kill channel for all goroutines that are listening: ::: not entirely sure of this one ???

	// ::: Get single input dialog < - - - - - - - - - - - - - - - - - - - - - - - - < -
	getSingleInput2 := func(title, prompt, defaultValue string, callback func(string, bool)) {
		confirmed := false // Track if OK was clicked
		d := dialog.NewEntryDialog(title, prompt, func(value string) {
			confirmed = true
			callback(value, true)
		}, window2)
		d.SetText(defaultValue)
		d.SetOnClosed(func() {
			if !confirmed { // Only trigger cancel if OK wasn’t clicked
				callback("", false)
			}
		})
		d.Show()
	}
	// ::: Dual input dialog < - - - - - - - - - - - - - - - - - - - - - - - - < -
	getDualInput2 := func(title, prompt1, prompt2, default1, default2 string, callback func(string, string, bool)) {
		calculating = true
		for _, btn := range buttons2 {
			btn.Disable()
		}
		entry1 := widget.NewEntry()
		entry1.SetText(default1)
		entry2 := widget.NewEntry()
		entry2.SetText(default2)
		submitButton := widget.NewButton("Run with those values",
			func() {
				callback(entry1.Text, entry2.Text, true)
				dialog.NewInformation("Submitted", "Values submitted", window2).Hide() // Hack to close dialog
				calculating = true
				for _, btn := range buttons2 {
					btn.Disable()
				}
			})
		form := container.NewVBox(
			widget.NewLabel(prompt1), entry1,
			widget.NewLabel(prompt2), entry2,
			container.NewHBox(submitButton),
		)
		d := dialog.NewCustom(title, "Dismiss dialogBox", form, window2)

		d.Resize(fyne.NewSize(400, 300))
		d.Show()
	}

	
	// ::: Buttons2


	RootsBtn2 := SetupRootsDemo(mgr, radicalEntry, workEntry, updateOutput2) // ::: just one line here, for this math button (see SetupRootsDemo)
	/*
		.
		.
	*/

	NilakanthaBtn2 := NewColoredButton(
		"Nilakantha -- input iterations\n" +
			"output up to 26 digits of pi",
		color.RGBA{255, 255, 100, 235},
		func() {
			if calculating {
				return
			}
			calculating = true
			for _, btn := range buttons2 {
				btn.Disable()
			}
			for _, btn := range nilaBut2 { // Refer to the comments in the initial assignment and creation of archimedesBtn1
				calculating = true
				btn.Enable()
			}
			getDualInput2("Input Required", "Number of iterations (suggest 300,000 -> 30,000,000  -> 300,000,000):", "Precision (suggest 128):",
				"30000000", "128", // 30,000,000
				func(itersStr, precStr string, ok bool) {
					calculating = true
					for _, btn := range buttons2 {
						btn.Disable()
					}
					if !ok {
						updateOutput2("Nilakantha calculation canceled")
						return
					}
					iters := 30000000 // 30,000,000
					precision := 128
					itersStr = removeCommasAndPeriods(itersStr) // ::: allow user to enter a number with a comma
					val1, err1 := strconv.Atoi(itersStr)
					if err1 != nil {
						fmt.Println("Error converting iterations val1:", err1) // handle error
						iters = 30000000
					} else {
						iters = val1
					}
					val2, err2 := strconv.Atoi(precStr)
					if err2 != nil {
						fmt.Println("Error converting precision val2:", err2) // handle error 
						updateOutput2("setting precision to 128")
						// fyneFunc(fmt.Sprintf("setting precision to 512")) //  ::: cannot do this instead because ??
						precision = 128
					} else {
						precision = val2
					}
					go NilakanthaBig(updateOutput2, iters, precision, done) // ::: probably want to add a done channel to this one
					calculating = false
					for _, btn := range buttons2 {
						btn.Enable()
					}
				})
		})

	// ::: Chud is temp here, Bailey concur will go here eventually 
	ChudnovskyBtn2 := NewColoredButton("chudnovsky -- takes input", color.RGBA{255, 255, 100, 235},
		func() {
			if calculating {
				return
			}
			calculating = true
			for _, btn := range buttons2 {
				btn.Disable()
			}
			for _, btn := range chudBut2 { // Refer to the comments in the initial assignment and creation of archimedesBtn1
				calculating = true
				btn.Enable()
			}
			getSingleInput2("Input Required", "Enter the number of digits for the chudnovsky calculation (e.g., 46):", "46",
				func(digitsStr string, ok bool) {
					var chudDigits int
					if !ok {
						updateOutput2("chudnovsky calculation canceled")
						return
					}
					chudDigits = 46
					val, err := strconv.Atoi(digitsStr)
					if err != nil {
						fmt.Println("Error converting input:", err) // handel error 
						updateOutput2("Invalid input, using default 46 digits")
					} else if val <= 0 {
						updateOutput2("Input must be positive, using default 46 digits")
					} else if val > 10000 {
						updateOutput2("Input must be less than 10,001, using default 46 digits")
					} else {
						chudDigits = val
					}
					go func() {
						chudnovskyBig(updateOutput2, chudDigits, done)
						calculating = false
						for _, btn := range buttons2 {
							btn.Enable()
						}
					}()
				})
		})

	/*
		.
		.
	*/

	rootBut2 = []*ColoredButton{RootsBtn2}
	chudBut2 = []*ColoredButton{ChudnovskyBtn2}
	nilaBut2 = []*ColoredButton{NilakanthaBtn2}

	buttons2 = []*ColoredButton{RootsBtn2, NilakanthaBtn2, ChudnovskyBtn2} // array used only for range btn.Enable()
	
	// ::: page-2 Lay-out
	content2 := container.NewVBox(
		widget.NewLabel("\nSelect a method to estimate π:\n"),

		radicalEntry,
		workEntry,
		
		container.NewGridWithColumns(4, RootsBtn2, NilakanthaBtn2, ChudnovskyBtn2),
		
		coloredScroll2, // Use coloredScroll2 directly or windowContent2 if you want an extra layer
	)
	windowContent2 := container.NewMax(bgwc2, content2) // Light green window bg // containers withing containers, labels on labels, functions in functions. Yet still inert. 
	
	/*
	      	window2.Canvas().SetOnTypedRune(func(r rune) { // Main-thread update loop using Fyne's lifecycle -- here an empty loop ::: see below:
	      	})

	      Every Fyne window has a Canvas, which is the drawable surface where all widgets (buttons, labels, etc.) are rendered. Calling window2.Canvas() gives you access to this canvas,
	   letting you interact with its properties or events.

	      .SetOnTypedRune(func(r rune) { ... }):
	      This method sets a callback function that Fyne calls whenever a user types a character (a "rune") into the window, provided the window has focus.

	      A rune in Go is an alias for int32 and represents a Unicode code point—essentially a single character, like 'a', '5', or 'π'. It’s more general than a byte, allowing it to handle
	   all kinds of text input (e.g., emojis, non-Latin scripts).

	      func(r rune) { ... }:
	      This is the callback function you provide. It runs on the main thread whenever a key is typed, and it receives the typed character (r) as an argument. The body of this
	   function (which you’ve shown as empty {}) is where you’d define what happens when a key is pressed.

	      "Main-thread update loop using Fyne's lifecycle":
	      The comment suggests this is part of Fyne’s event-driven lifecycle. Fyne runs its GUI in a single-threaded, event-based model on the main thread. When you set this callback, it
	   hooks into that lifecycle, ensuring your response to keypresses happens synchronously with other GUI updates (like rendering or widget changes). This avoids concurrency issues that
	   could arise if you tried to update the GUI from another thread.
	   :::
	      In short, window2.Canvas().SetOnTypedRune(func(r rune) { ... }) lets you capture and respond to keyboard input in window2. For example:
	      If a user types 'q', the function runs with r = 'q'.

	      You could use this to close the window, update a label, or trigger a calculation based on the input.

	   :::    Since your example has an empty function body ({}), it currently does nothing—it’s just a placeholder. The real action depends on what you put inside the {}.
	
	*/

	window2.SetContent(windowContent2) // Set once with the full layout
	return window2
} // end of createWindow2 "it's only a label". "no Show, no go" 


// ::: ------------------------------------------------------------------------------------------------------------------------------------------------------------
func createWindow3(myApp fyne.App) fyne.Window {
	// Similar structure to createWindow2
	window3 := myApp.NewWindow("Odd Pi calculators")
	window3.Resize(fyne.NewSize(1900, 1600))
	outputLabel3 := widget.NewLabel("Odd Pi calculators, make a selection")
	outputLabel3.Wrapping = fyne.TextWrapWord
	scrollContainer3 := container.NewScroll(outputLabel3)
	scrollContainer3.SetMinSize(fyne.NewSize(1900, 1300))
	buttonContainer3 := container.NewGridWithColumns(4,
		widget.NewButton("Button 9", func() {}),
		widget.NewButton("Button 10", func() {}),
		widget.NewButton("Button 11", func() {}),
		widget.NewButton("Button 12", func() {}),
		widget.NewButton("Button 13", func() {}),
		widget.NewButton("Button 14", func() {}),
		widget.NewButton("Button 15", func() {}),
		widget.NewButton("Button 16", func() {}),
	)
	content3 := container.NewVBox(buttonContainer3, scrollContainer3)
	window3.SetContent(content3)
	return window3
}

// ::: ------------------------------------------------------------------------------------------------------------------------------------------------------------
func createWindow4(myApp fyne.App) fyne.Window {
	// Similar structure to createWindow2
	window4 := myApp.NewWindow("Misc Maths")
	window4.Resize(fyne.NewSize(1900, 1600))
	outputLabel4 := widget.NewLabel("Misc Maths, make a selection")
	outputLabel4.Wrapping = fyne.TextWrapWord
	scrollContainer4 := container.NewScroll(outputLabel4)
	scrollContainer4.SetMinSize(fyne.NewSize(1900, 1300))
	buttonContainer4 := container.NewGridWithColumns(4,
		widget.NewButton("Button 17", func() {}), widget.NewButton("Button 18", func() {}), widget.NewButton("Button 19", func() {}), widget.NewButton("Button 20", func() {}),
		widget.NewButton("Button 21", func() {}), widget.NewButton("Button 22", func() {}), widget.NewButton("Button 23", func() {}), widget.NewButton("Button 24", func() {}),
	)
	content4 := container.NewVBox(buttonContainer4, scrollContainer4)
	window4.SetContent(content4)
	return window4
}
package main

import (
	"fmt"
	"fyne.io/fyne/v2/widget"
	"image/color"
	"math"
	"os"
	"sort"
	"strconv"
	"strings"
	"time"
)

// @formatter:off

var (
	pairsSlice []Pairs
	sortedResults             []Results
	mathSqrtCheat            float64
	mathCbrtCheat            float64
	diffOfLarger              int
	diffOfSmaller             int
	precisionOfRoot           int
	mgr             = NewTrafficManager(outputLabel2) // ::: - -
)

type Results struct {
	result float64
	pdiff  float64
}

// SetupRootsDemo sets up the roots demo UI and returns the button for window2
func SetupRootsDemo(mgr *TrafficManager, radicalEntry, workEntry *widget.Entry, fyneFunc func(string)) *ColoredButton {
	rootsBtn := NewColoredButton(
		"Roots demo usage: enter an integer in each of the above fields\n" +
			"2 or 3 in the first field, then any positive integer in the second\n" +
			"then click this button to run the calculation of square or cube root\n" +
			"                   -*-*- Rick's own-favorite method -*-*-     ",
		color.RGBA{255, 255, 100, 235},
		func() {
			if mgr.IsCalculating() {
				return
			}
			trimmedRadicalString := strings.TrimRight(radicalEntry.Text, " ")
			radical, err := strconv.Atoi(trimmedRadicalString)
			if err != nil || (radical != 2 && radical != 3) {
				updateOutput2("Invalid radical: enter 2 or 3\n")
				fyneFunc(fmt.Sprintf("Invalid radical: enter 2 or 3\n"))
				return
			}
			trimmedWorkPieceString := strings.TrimRight(workEntry.Text, " ")
			workPiece, err := strconv.Atoi(trimmedWorkPieceString)
			if err != nil || workPiece < 0 {
				updateOutput2("Invalid number: enter a non-negative integer\n")
				fyneFunc(fmt.Sprintf("Invalid number: enter a non-negative integer\n"))
				return
			}
			fmt.Printf(" ::: - Radical is set to: %d\n", radical)
			fmt.Printf(" ::: - Work Piece is set to: %d\n", workPiece)
			mgr.SetRadical(radical)
			mgr.SetWorkPiece(workPiece)
			mgr.SetCalculating(true)
			for _, btn := range buttons2 {
				btn.Disable()
			}
			for _, btn := range rootBut2 {
				btn.Enable()
			}
			go func() {
					defer func() {
						mgr.Reset()
						for _, btn := range buttons2 {
							btn.Enable()
						}
					}()
				xRootOfy(updateOutput2) // ::: formatted to highlight the meat
					mgr.SetCalculating(false)
			}()
		},
	)
	return rootsBtn
}

func xRootOfy(fyneFunc func(string)) {
	usingBigFloats = false
	TimeOfStartFromTop := time.Now()

	radical2or3 := mgr.GetRadical()
	workPiece := mgr.GetWorkPiece()

	radical2or3, workPiece = setPrecisionForSquareOrCubeRoot(mgr, radical2or3, workPiece, updateOutput2) // sets precision only, no actual need to digest and pass our inputs
	mgr.SetRadical(radical2or3) // no need for these
	mgr.SetWorkPiece(workPiece)

	updateOutput2("\n\nBuilding table...\n")
	buildPairsSlice(radical2or3)
	updateOutput2("Table built, starting calculation...\n")
	startBeforeCall := time.Now()
	
	var indx int 
	for i := 0; i < 400000; i += 2 { // this is meant to be a pretty big loop 825,000 is the number of 
		if mgr.ShouldStop() {
			updateOutput2("Calculation of a root aborted\n")
			fyneFunc(fmt.Sprintf("Calculation of a root aborted\n"))
			return
		}
		readPairsSlice(i, startBeforeCall, radical2or3, workPiece, updateOutput2)
		handlePerfectSquaresAndCubes(TimeOfStartFromTop, radical2or3, workPiece, mgr)
		if diffOfLarger == 0 || diffOfSmaller == 0 { 
			break // because we have a perfect square or cube
		}
		if i%80000 == 0 && i > 0 { // if remainder of div is 0 (every 80,000 iterations) conditional progress updates print
			stringVindx := formatInt64WithThousandSeparators(int64(indx))
			updateOutput2(fmt.Sprintf("\n%s iterations completed... of 400,000\n", stringVindx))
			updateOutput2(fmt.Sprintf("\n... still working ...\n")) // ok
			
			fmt.Printf("%s iterations completed... of 400,000\n", stringVindx)
			fmt.Println(i, "... still working ...")
		}
		indx = i // save/copy to a wider scope for later use outside this loop
	}
	fmt.Println("Loop completed at index:", indx) // Debug
	
	// ::: Show the final result
	fmt.Println("Entering result block, mathSqrtCheat 'square':", mathSqrtCheat, "mathCbrtCheat 'cube':", mathCbrtCheat) // Debug
	// ::: "Entering result block ... "
	
	t_s2 := time.Now()
	elapsed_s2 := t_s2.Sub(TimeOfStartFromTop)
	if diffOfLarger != 0 || diffOfSmaller != 0 { // if not a perfect square or cube do this else skip due to detection of perfect result
		defer func() {
			if r := recover(); r != nil {
				fmt.Println("Panic in result block:", r)
				updateOutput2("\nError calculating result\n")
			}
		}()
		fileHandle, err31 := os.OpenFile("dataLog-From_calculate-pi-and-friends.txt", os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
		check(err31)
		defer fileHandle.Close()

		Hostname, _ := os.Hostname()
		fmt.Fprintf(fileHandle, "\n  -- %d root of %d by a ratio of perfect Products -- on %s \n", radical2or3, workPiece, Hostname)
		fmt.Fprint(fileHandle, "was run on: ", time.Now().Format(time.ANSIC), "\n")
		fmt.Fprintf(fileHandle, "%d was total Iterations \n", indx)

		fmt.Println("Sorting results...") // Debug
		sort.Slice(sortedResults, func(i, j int) bool { return sortedResults[i].pdiff < sortedResults[j].pdiff })
		fmt.Println("Sorted results, length:", len(sortedResults)) // Debug

		if len(sortedResults) > 0 {
			if radical2or3 == 2 {
				result := fmt.Sprintf("\n%0.9f, it's the best approximation for the Square Root of %d", sortedResults[0].result, workPiece)
				fmt.Println("Updating GUI with:", result) // Debug
				updateOutput2(result)
				fmt.Println("GUI updated, printing to console...") // Debug
				fmt.Printf("%s\n", result)
				// fyneFunc(fmt.Sprintf("\nSquare-root Result is: %s\n", result))
				fmt.Println("Writing to file...") // Debug
				fmt.Fprintf(fileHandle, "%s \n", result)
				fmt.Println("File written") // Debug
			}
			if radical2or3 == 3 {
				result := fmt.Sprintf("\n%0.9f, it's the best approximation for the Cube Root of %d", sortedResults[0].result, workPiece)
				fmt.Println("Updating GUI with:", result) // Debug
				updateOutput2(result)
				fmt.Println("GUI updated, printing to console...") // Debug
				fmt.Printf("%s\n", result)
				// fyneFunc(fmt.Sprintf("\nCube-root Result is: %s\n", result))
				fmt.Println("Writing to file...") // Debug
				fmt.Fprintf(fileHandle, "%s \n", result)
				fmt.Println("File written") // Debug
			}
		} else {
			updateOutput2(fmt.Sprintf("\nUpdate: No results found within precision %d after %d iterations", precisionOfRoot, indx))
			fmt.Printf("No results found within precision %d after %d iterations\n", precisionOfRoot, indx)
			fyneFunc(fmt.Sprint("\nFyne: No results found within precision %d after %d iterations\n", precisionOfRoot, indx))
		}

		TotalRun := elapsed_s2.String()
		fmt.Fprintf(fileHandle, "Total run was %s \n ", TotalRun)
		fmt.Printf("Calculation completed in %s\n", elapsed_s2)
		fyneFunc(fmt.Sprintf("\nCalculation completed in %s\n", elapsed_s2))
	} else {
		fmt.Println("Skipped result block due to perfect result detection") // Debug
	}
}

func readPairsSlice(i int, startBeforeCall time.Time, radical2or3, workPiece int, fyneFunc func(string)) {
	oneReadOfSmallerRoot := pairsSlice[i].root // Read a smaller PP and its root (just once) for each time readPairsSlice is called
	oneReadOfSmallerPP := pairsSlice[i].product
	
	for iter := 0; iter < 410000 && i < len(pairsSlice); iter++ { // go big, but not so big that you would read past the end of the pairsSlice
		i++
		largerPerfectProduct := pairsSlice[i].product // i has been incremented since the initial one-time read of oneReadOfSmallerPP

		// ... and, keep incrementing the i until largerPerfectProduct is greater than (oneReadOfSmallerPP * workPiece)
		if largerPerfectProduct > oneReadOfSmallerPP*workPiece { // For example: workPiece may be 11, 3.32*3.32.   Larger PP may be 49, 7*7.   Smaller oneReadPP may be 4, 2*2. ::: oneRead is 4
			
			ProspectivePHitOnLargeSide := largerPerfectProduct // rename it, badly;
			rootOfProspectivePHitOnLargeSide := pairsSlice[i].root // grab larger side's root
			
			ProspectivePHitOnSmallerSide := pairsSlice[i-1].product
			rootOfProspectivePHitOnSmallerSide := pairsSlice[i-1].root

			
			// we next look at two roots (PHs) of two PPs. 
			diffOfLarger = ProspectivePHitOnLargeSide - workPiece*oneReadOfSmallerPP // ::: PH_larger - (WP * _once)     7 - (11 * 4)
			// What does it tell us if we find that the sum of one of the larger roots from the table : ProspectivePHitOnLargeSide
			// and/plus the negative of another smaller root from the table (times our WP) turns out to be zero?
			
			
			diffOfSmaller = workPiece*oneReadOfSmallerPP - ProspectivePHitOnSmallerSide // ::: (WP * _once) - PH_smaller    (11 * 4) - 

			if diffOfLarger == 0 {
				fmt.Println(colorCyan, "\n The", radical2or3, "root of", workPiece, "is", colorGreen,
					float64(rootOfProspectivePHitOnLargeSide)/float64(oneReadOfSmallerRoot), colorReset, "\n")
				fyneFunc(fmt.Sprintf("\n The %d root of %d is %0.33f\n\n", radical2or3, workPiece, float64(rootOfProspectivePHitOnLargeSide)/float64(oneReadOfSmallerRoot)))
				
				mathCbrtCheat = math.Cbrt(float64(workPiece))
				break
			}
			if diffOfSmaller == 0 {
				fmt.Println(colorCyan, "\n The", radical2or3, "root of", workPiece, "is", colorGreen,
					float64(rootOfProspectivePHitOnSmallerSide)/float64(oneReadOfSmallerRoot), colorReset, "\n")
				fyneFunc(fmt.Sprintf("\n The %d root of %d is %0.33f\n\n", radical2or3, workPiece, float64(rootOfProspectivePHitOnSmallerSide)/float64(oneReadOfSmallerRoot)))
				
				mathSqrtCheat = math.Sqrt(float64(workPiece)) // ::: I cheated? Yea, a bit. But only in order to generate verbiage to print re a perfect root having been found 
				mathCbrtCheat = math.Cbrt(float64(workPiece))
				break
			}

			if diffOfLarger < precisionOfRoot {
				result := float64(rootOfProspectivePHitOnLargeSide) / float64(oneReadOfSmallerRoot)
				pdiff := float64(diffOfLarger) / float64(ProspectivePHitOnLargeSide)
				
				sortedResults = append(sortedResults, Results{result: result, pdiff: pdiff})
				
				fmt.Printf("Found large prospect at index %d: result=%f, diff=%d\n", i, result, diffOfLarger) // Debug
				fyneFunc(fmt.Sprintf("Found large prospect at index %d: result=%f, diff=%d\n", i, result, diffOfLarger)) // Debug
				// break
				if diffOfLarger < 2 {break}
			}
			if diffOfSmaller < precisionOfRoot {
				result := float64(rootOfProspectivePHitOnSmallerSide) / float64(oneReadOfSmallerRoot)
				pdiff := float64(diffOfSmaller) / float64(ProspectivePHitOnSmallerSide)
				
				sortedResults = append(sortedResults, Results{result: result, pdiff: pdiff})
				
				fmt.Printf("Found small prospect at index %d: result=%f, diff=%d\n", i, result, diffOfSmaller) // Debug
				fyneFunc(fmt.Sprintf("Found small prospect at index %d: result=%f, diff=%d\n", i, result, diffOfSmaller)) // Debug
				// break
				if diffOfSmaller < 2 {break}
			}

// ::: we will be potentially duplicating Results struct -> slice 
			// larger side section: ----------------------------------------------------------------------------------------------------------------------------------------
			// ---------------------------------------------------------------------------------------------------------------------------------------------------------------
			if diffOfLarger < precisionOfRoot { // report the prospects, their differences, and the calculated result for the Sqrt or Cbrt
				fmt.Println("small PP is", colorCyan, oneReadOfSmallerPP, colorReset, "and, slightly on the higher side of", workPiece,
					"* that we found a PP of", colorCyan, ProspectivePHitOnLargeSide, colorReset, "a difference of", diffOfLarger)
				fyneFunc(fmt.Sprintf("\nsmall PP is %d and, slightly on the higher side of %d * that we found a PP of %d a difference of %d\n", oneReadOfSmallerPP, workPiece, ProspectivePHitOnLargeSide, diffOfLarger))
				
				fmt.Println("the ", radical2or3, " root of ", workPiece, " is calculated as ", colorGreen,
					float64(rootOfProspectivePHitOnLargeSide)/float64(oneReadOfSmallerRoot), colorReset)
				fyneFunc(fmt.Sprintf("\nthe %d root of %d is calculated as %0.6f \n", radical2or3, workPiece, float64(rootOfProspectivePHitOnLargeSide)/float64(oneReadOfSmallerRoot)))
				
				fmt.Printf("with pdiff of %0.4f \n", (float64(diffOfLarger)/float64(ProspectivePHitOnLargeSide))*100000)
				fyneFunc(fmt.Sprintf("with pdiff of %0.4f \n", (float64(diffOfLarger)/float64(ProspectivePHitOnLargeSide))*100000))
				// save the result to an accumulator array so we can Fprint all such hits at the very end
				// List_of_2_results_case18 = append(List_of_2_results_case18, float64(rootOfProspectivePHitOnLargeSide) / float64(oneReadOfSmallerRoot) )
				// corresponding_diffs = append(corresponding_diffs, diffOfLarger)
				// diffs_as_percent = append(diffs_as_percent, float64(diffOfLarger)/float64(ProspectivePHitOnLargeSide))

				// in the next five lines we load (append) a record into/to the file (array) of Results
				Result1 := Results{
					result: float64(rootOfProspectivePHitOnLargeSide) / float64(oneReadOfSmallerRoot),
					pdiff:  float64(diffOfLarger) / float64(ProspectivePHitOnLargeSide),
				}
				sortedResults = append(sortedResults, Result1)

				t2 := time.Now()
				elapsed2 := t2.Sub(startBeforeCall)
				// if needed, notify the user that we are still working
				Tim_win = 0.178
				if radical2or3 == 3 {
					if workPiece > 13 {
						Tim_win = 0.0012
					} else {
						Tim_win = 0.003
					}
				}
				if elapsed2.Seconds() > Tim_win {
					fmt.Println(elapsed2.Seconds(), "Seconds have elapsed ... working ...\n")
					fyneFunc(fmt.Sprintf("\n%0.4f Seconds have elapsed ... working ...\n\n", elapsed2.Seconds()))
				}
			}

			// smaller side section: ----------------------------------------------------------------------------------------------------------------------------------------
			// ---------------------------------------------------------------------------------------------------------------------------------------------------------------
			if diffOfSmaller < precisionOfRoot { // report the prospects, their differences, and the calculated result for the Sqrt or Cbrt
				fmt.Println("small PP is", colorCyan, oneReadOfSmallerPP, colorReset, "and, slightly on the lesser side of", workPiece,
					"* that we found a PP of", colorCyan, ProspectivePHitOnSmallerSide, colorReset, "a difference of", diffOfSmaller)
				fyneFunc(fmt.Sprintf("\nsmall PP is %d and, slightly on the higher side of %d * that we found a PP of %d a difference of %d\n", oneReadOfSmallerPP, workPiece, ProspectivePHitOnSmallerSide, diffOfSmaller))
				
				fmt.Println("the ", radical2or3, " root of ", workPiece, " is calculated as ", colorGreen,
					float64(rootOfProspectivePHitOnSmallerSide)/float64(oneReadOfSmallerRoot), colorReset)
				fyneFunc(fmt.Sprintf("\nthe %d root of %d is calculated as %0.6f \n", radical2or3, workPiece, float64(rootOfProspectivePHitOnSmallerSide)/float64(oneReadOfSmallerRoot)))
				
				fmt.Printf("with pdiff of %0.4f \n", (float64(diffOfSmaller)/float64(ProspectivePHitOnSmallerSide))*100000)
				fyneFunc(fmt.Sprintf("with pdiff of %0.4f \n", (float64(diffOfSmaller)/float64(ProspectivePHitOnSmallerSide))*100000))
				
				// save the result to three accumulator arrays so we can Fprint all such hits, diffs, and p-diffs, at the very end of run
				// List_of_2_results_case18 = append(List_of_2_results_case18, float64(rootOfProspectivePHitOnSmallerSide) / float64(oneReadOfSmallerRoot) )
				// corresponding_diffs = append(corresponding_diffs, diffOfSmaller)
				// diffs_as_percent = append(diffs_as_percent, float64(diffOfSmaller)/float64(ProspectivePHitOnSmallerSide))
				// ***** ^^^^ ****** the preceeding was replaced with the following five lines *******************************************

				// in the next five lines we load (append) a record into/to the file (array) of Results
				Result1 := Results{
					result: float64(rootOfProspectivePHitOnSmallerSide) / float64(oneReadOfSmallerRoot),
					pdiff:  float64(diffOfSmaller) / float64(ProspectivePHitOnSmallerSide),
				}
				sortedResults = append(sortedResults, Result1)

				t2 := time.Now()
				elapsed2 := t2.Sub(startBeforeCall)
				// if needed, notify the user that we are still working
				Tim_win = 0.178
				if radical2or3 == 3 {
					if workPiece > 13 {
						Tim_win = 0.0012
					} else {
						Tim_win = 0.003
					}
				}
				if elapsed2.Seconds() > Tim_win {
					fmt.Println(elapsed2.Seconds(), "Seconds have elapsed ... working ...\n")
					fyneFunc(fmt.Sprintf("\n%0.4f Seconds have elapsed ... working ...\n\n", elapsed2.Seconds()))
				}
			}
			break
		}
	}
}

// handlePerfectSquaresAndCubes reports perfect squares/cubes to file and UI
func handlePerfectSquaresAndCubes(TimeOfStartFromTop time.Time, radical2or3, workPiece int, mgr *TrafficManager) {
	if diffOfLarger == 0 || diffOfSmaller == 0 {
		t_s1 := time.Now()
		elapsed_s1 := t_s1.Sub(TimeOfStartFromTop)

		fileHandle, err1 := os.OpenFile("dataLog-From_calculate-pi-and-friends.txt", os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
		check(err1)
		defer fileHandle.Close()

		Hostname, _ := os.Hostname()
		fmt.Fprintf(fileHandle, "\n  -- %d root of %d by a ratio of PerfectProducts -- selection #%d on %s \n", radical2or3, workPiece, 1, Hostname)
		fmt.Fprint(fileHandle, "was run on: ", time.Now().Format(time.ANSIC), "\n")
		fmt.Fprintf(fileHandle, "Total run was %s \n ", elapsed_s1.String())

		if radical2or3 == 2 {
			result := fmt.Sprintf("Perfect square: %0.0f is the %d root of %d", mathSqrtCheat, radical2or3, workPiece)
			updateOutput2(result)
			fmt.Fprintf(fileHandle, "the %d root of %d is %0.0f \n", radical2or3, workPiece, mathSqrtCheat)
		}
		if radical2or3 == 3 {
			result := fmt.Sprintf("Perfect cube: %0.0f is the %d root of %d", mathCbrtCheat, radical2or3, workPiece)
			updateOutput2(result)
			fmt.Fprintf(fileHandle, "the %d root of %d is %0.0f \n", radical2or3, workPiece, mathCbrtCheat)
		}
	}
}


// setPrecisionForSquareOrCubeRoot adjusts precision based on radical and workPiece
func setPrecisionForSquareOrCubeRoot(mgr *TrafficManager, radical2or3, workPiece int, fyneFunc func(string)) (int, int) {
	if radical2or3 == 3 { // ::: setting the optimal precision this way is a crude kluge
		if workPiece > 4 {
			precisionOfRoot = 1700
			fmt.Println("\n Default precision is 1700 \n")
			fyneFunc(fmt.Sprintf("\n Default precision is 1700 \n"))
		}
		if workPiece == 2 || workPiece == 11 || workPiece == 17 {
			precisionOfRoot = 600
			fmt.Println("\n resetting precision to 600 \n")
			fyneFunc(fmt.Sprintf("\n resetting precision to 600 \n"))
		}
		if workPiece == 3 || workPiece == 4 || workPiece == 14 {
			precisionOfRoot = 900
			fmt.Println("\n resetting precision to 900 \n")
			fyneFunc(fmt.Sprintf("\n resetting precision to 900 \n"))
		}
	}
	if radical2or3 == 2 {
		precisionOfRoot = 4
	}
	return radical2or3, workPiece
}

// Pairs A struct to contain two related whole numbers: an identity product (perfect square or cube), e.g. 49; and its root, which in that case would be 7 
type Pairs struct {
	product int
	root int
}

// build a table of ::: perfect squares or cubes
func buildPairsSlice(radical2or3 int) { // ::: - -
	var identityProduct int
	pairsSlice = nil // Clear/reset the slice between runs
	root := 2 // Because; 2 is the smallest possible whole-number root, i.e., it's the square root of 4 and the cube root of 8 // I used to have this as root := 10 but I do not recall why : (how I had decided on 10?)
	for i := 0; i < 825000; i++ {
		root++
		if radical2or3 == 3 {                   // ::: depending on passed radical 
			identityProduct = root * root * root
		}
		if radical2or3 == 2 {
			identityProduct = root * root
		}
		pairsSlice = append(pairsSlice, Pairs{
			product: identityProduct,
			root:  root,
		})
	}
}